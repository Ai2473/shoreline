package com.caspian.impl.module.exploit;

import com.caspian.Caspian;
import com.caspian.api.config.Config;
import com.caspian.api.config.setting.NumberConfig;
import com.caspian.api.event.EventStage;
import com.caspian.api.event.listener.EventListener;
import com.caspian.api.module.ModuleCategory;
import com.caspian.api.module.ToggleModule;
import com.caspian.impl.event.TickEvent;
import com.caspian.impl.event.network.PacketEvent;
import com.caspian.impl.event.render.RenderWorldEvent;
import com.caspian.impl.event.world.ChunkLoadEvent;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.fluid.FluidState;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.network.packet.s2c.play.BlockUpdateS2CPacket;
import net.minecraft.network.packet.s2c.play.ChunkDataS2CPacket;
import net.minecraft.network.packet.s2c.play.ChunkDeltaUpdateS2CPacket;
import net.minecraft.network.packet.s2c.play.ExplosionS2CPacket;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.util.math.Direction;
import net.minecraft.world.BlockView;
import net.minecraft.world.chunk.WorldChunk;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.*;

/**
 *
 *
 * @author linus
 * @since 1.0
 *
 *
 */
public class NewChunksModule extends ToggleModule
{
    public final Config<Integer> offsetConfig = new NumberConfig<>("YOffset",
            "Y-level offset of the render", 0, 0, 16);

    //
    private static final Direction[] HORIZONTALS = new Direction[]
            {
                    Direction.EAST, Direction.NORTH, Direction.WEST,
                    Direction.SOUTH, Direction.UP
            };

    //
    private final ConcurrentMap<ChunkPos, Long> loading =
            new ConcurrentHashMap<>();
    private final ConcurrentMap<ChunkPos, Long> loaded =
            new ConcurrentHashMap<>();

    //
    private int chunkCalls;
    private final ExecutorCompletionService<ChunkPos> chunkService =
            new ExecutorCompletionService<>(executor);
    private int oldCalls;
    private final ExecutorCompletionService<ChunkPos> oldService =
            new ExecutorCompletionService<>(executor);

    //
    private final Set<ChunkPos> chunks = new HashSet<>();
    private final Set<ChunkPos> old = new HashSet<>();

    /**
     *
     *
     */
    public NewChunksModule()
    {
        super("NewChunks", "Highlights newly generated chunks",
                ModuleCategory.EXPLOITS);
    }

    /**
     *
     *
     * @param event
     */
    @EventListener
    public void onTick(TickEvent event)
    {
        if (event.getStage() == EventStage.POST)
        {
            try
            {
                int chunkResults = 0;
                int oldResults = 0;
                for (int i = 0; i < chunkCalls; i++)
                {
                    Future<ChunkPos> result = chunkService.take();
                    if (result != null && result.get() != null)
                    {
                        ChunkPos pos = result.get();
                        chunks.add(pos);
                        chunkResults++;
                    }
                }

                for (int i = 0; i < oldCalls; i++)
                {
                    Future<ChunkPos> result = oldService.take();
                    if (result != null && result.get() != null)
                    {
                        ChunkPos pos = result.get();
                        old.add(pos);
                        oldResults++;
                    }
                }

                chunkCalls -= chunkResults;
                oldCalls -= oldResults;
            }

            catch (InterruptedException | ExecutionException e)
            {
                Caspian.error("Failed to check chunk");
                e.printStackTrace();
            }
        }
    }

    /**
     *
     *
     * @param event
     */
    @EventListener
    public void onPacketInbound(PacketEvent.Inbound event)
    {
        if (mc.world != null && mc.player != null)
        {
            if (event.getPacket() instanceof ChunkDeltaUpdateS2CPacket packet)
            {
                packet.visitUpdates((pos, state) -> onBlockUpdate(pos.toImmutable(), state));
            }

            else if (event.getPacket() instanceof ChunkDataS2CPacket packet)
            {
                ChunkPos pos = new ChunkPos(packet.getX(), packet.getZ());
                WorldChunk chunk = new WorldChunk(mc.world, pos);
                chunk.loadFromPacket(packet.getChunkData().getSectionsDataBuf(),
                        new NbtCompound(), packet.getChunkData()
                                .getBlockEntities(packet.getX(), packet.getZ()));
                onChunkUpdate(pos);
            }

            else if (event.getPacket() instanceof BlockUpdateS2CPacket packet)
            {
                onBlockUpdate(packet.getPos(), packet.getState());
            }

            else if (event.getPacket() instanceof ExplosionS2CPacket packet)
            {
                for (BlockPos pos : packet.getAffectedBlocks())
                {
                    onBlockUpdate(pos, Blocks.AIR.getDefaultState());
                }
            }
        }
    }

    /**
     *
     *
     * @param event
     */
    @EventListener
    public void onChunkLoad(ChunkLoadEvent event)
    {
        if (event.getStage() == EventStage.PRE)
        {
            loading.put(event.getPos(), System.currentTimeMillis());
        }

        if (event.getStage() == EventStage.PRE)
        {
            loaded.put(event.getPos(),
                    System.currentTimeMillis() - loading.remove(event.getPos()));
        }
    }

    /**
     *
     *
     * @param event
     */
    @EventListener
    public void onRenderWorld(RenderWorldEvent event)
    {
        for (ChunkPos pos : chunks)
        {
            // RenderManager.renderPlane(pos, Colors.normalize(loaded.get(pos),
            //       0x4000ff00, 0x40ff0000));
        }
    }

    /**
     *
     *
     * @param pos
     */
    public void onChunkUpdate(ChunkPos pos)
    {
        oldService.submit(() ->
        {
            BlockView view = mc.world.getChunk(pos.x, pos.z);
            if (view == null)
            {
                if (!chunks.contains(pos))
                {
                    for (int x = 0; x < 16; x++)
                    {
                        for (int y = mc.world.getBottomY(); y < mc.world.getTopY(); y++)
                        {
                            for (int z = 0; z < 16; z++)
                            {
                                FluidState fluid =
                                        view.getFluidState(new BlockPos(x, y, z));
                                if (!fluid.isEmpty() && !fluid.isStill())
                                {
                                    return pos;
                                }
                            }
                        }
                    }
                }
            }

            return null;
        });
        oldCalls++;
    }

    /**
     *
     *
     * @param pos
     * @param state
     */
    public void onBlockUpdate(BlockPos pos, BlockState state)
    {
        chunkService.submit(() ->
        {
            // checks if the fluid state is moving
            if (!state.getFluidState().isEmpty() && !state.getFluidState().isStill())
            {
                ChunkPos chunkPos = new ChunkPos(pos);
                if (!old.contains(chunkPos))
                {
                    for (Direction direction : HORIZONTALS)
                    {
                        if (mc.world.getBlockState(pos.offset(direction))
                                .getFluidState().isStill())
                        {
                            loading.put(chunkPos, System.currentTimeMillis());
                            return chunkPos;
                        }
                    }
                }
            }

            return null;
        });
        chunkCalls++;
    }
}
